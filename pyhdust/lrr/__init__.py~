# -*- coding:utf-8 -*-

import sys
import os
import numpy as np
import itertools as it
import pyhdust.phc as phc

__author__ = "Leandro Rimulo"
__email__ = "lrrimulo@gmail.com"

cwd='/home/lrrimulo/Dropbox/Main_programs/pyhdust/rimulo'

def integrate_trapezia(f,df):
    """Integration by trapezia, with differentials of possibly different size:
             ____
             \
    Returns: /___ f df
    
    INPUT: lists/arrays of values of f and df (len(f)=len(df)+1)"""
    if len(f) < 2 or len(df) != len(f)-1:
        func_name = sys._getframe().f_code.co_name
        print '<<',func_name,'>>'
        print 'There is something wrong with the integration!'
        print ''
        return np.nan
    else: 
        soma=0.0
        for i in xrange(0,len(f)-1):
            termo=float((f[i]+f[i+1])*df[i])/2.
            if not np.isnan(termo):
                soma+=termo
        return soma
        
def dec_2_binary(number,dim=None):
    """Returns the number in its binary form."""

    addreverse=[]; res=number%2; quo=number/2
    addreverse.append(res)
    while quo != 0: res=quo%2; quo=quo/2; addreverse.append(res)
    
    if dim != None and dim < len(addreverse):
        func_name = sys._getframe().f_code.co_name
        print '<<',func_name,'>>'
        print 'I need more dimensions to write this binary number!'
        print ''
        return np.nan
    elif dim != None and dim >= len(addreverse): addn=np.array([0 for k in xrange(0,dim)])
    else: addn=np.array([0 for k in xrange(0,len(addreverse))])
    
    for j in xrange(0,len(addreverse)): addn[len(addn)-1-j]=addreverse[j]

    return addn
    



##########################################

def interLinND(X, X0, X1, Fx):
    """
    N-dimensional linear interpolation.

    | INPUT:
    | X = list containing the position in with the interpolation is desired;
    | X0 = list containing minimal values of the interval;
    | X1 = list containing maximum values of the inveral
    | Fx = list containing function values along the interval, ORDERED BY DIMENSTION.
    |   Example: Fx = [F00, F01, F10, F11]

    OUTPUT: interpolated value (float)"""
    X = np.array(X)     # an array of N positions
    X0 = np.array(X0)   # an array of N backward positions
    X1 = np.array(X1)   # an array of N forward positions
    Xd = (X-X0)/(X1-X0) # an array of N normalized positions
    DX = np.array([ [(1-x),x] for x in Xd ]) # an array containing N "2-arrays" 
                                             # of backward and forward normalized intervals
    # OBS: Fx is an array of 2**N elements correctly arranged
    i = 0
    F = 0
    for prod in it.product(*DX):    # itertools.product(*DX) creates 2**N tuples of 
                                    # N elements => the set of tuples encompass all the 
                                    # possibilities of combinations of normalized intervals. 
        F+= Fx[i]*np.product(prod) # np.product returns the product of the N elements of each
                                   # of the 2**N tuples
        i+= 1
    #
    return F

    
def low_high(mmodel,mmodelaxis):

    low=[]; high=[]; ind=[]
    for j in range(0,len(mmodelaxis)):
        chave=0
        # If it is to extrapolate to a value before a minimum
        if mmodel[j]<mmodelaxis[j][0]:
            low.append(mmodelaxis[j][0]); ind.append(0)
            high.append(mmodelaxis[j][1])
            chave+=1
        # If it is to extrapolate to a value after a maximum
        if mmodel[j]>mmodelaxis[j][len(mmodelaxis[j])-1]:
            low.append(mmodelaxis[j][len(mmodelaxis[j])-2]); ind.append(len(mmodelaxis[j])-2)
            high.append(mmodelaxis[j][len(mmodelaxis[j])-1])
            chave+=1
        # If it is to interpolate
        i=0
        while chave==0:
            if mmodel[j]>=mmodelaxis[j][i] and mmodel[j]<=mmodelaxis[j][i+1] \
                    and i<len(mmodelaxis[j][:])-1:
                low.append(mmodelaxis[j][i]); ind.append(i)
                high.append(mmodelaxis[j][i+1])
                chave+=1
            i+=1

    return np.array(low),np.array(high),np.array(ind)

def find_index(ind,axis):

    leng=[len(x) for x in axis]
    indd=0
    for i in xrange(0,len(axis)-1):
        prod=1
        for j in xrange(i+1,len(axis)):
            prod=prod*leng[j]
        indd+=ind[i]*prod
    indd+=ind[len(axis)-1]
    
    return indd
    

def build_Fx(axis,values,ind):
    Fx=[]
    for i in xrange(0,2**len(ind)):
        addn=dec_2_binary(i,len(ind))
        newind=np.array([ind[j]+addn[j] for j in xrange(len(ind))])
        indd=find_index(newind,axis)
        Fx.append(values[indd])
    Fx=np.array(Fx)
    return Fx
    
def interpLinND(X,axis,values):
    """N-dimensional linear interpolation.
    
    | INPUT:
    | X = the position in with the interpolation is desired
    | axis = list of vectors that create the basis of the space
    | values = vector with all the values of the function to be interpolated
    """
    
    if len(X) != len(axis):
        func_name = sys._getframe().f_code.co_name
        print '<<',func_name,'>>'
        print 'X and axis must have the same dimension!'
        print ''
        return np.nan
    low,high,ind=low_high(X,axis)
    Fx=build_Fx(axis,values,ind)
    interp=interLinND(X, low, high, Fx)
    return interp

# EXAMPLE ..............................................................
#
# x=[1.,2.]
# y=[3.,4.,5.]
# z=[6.,7.,8.,9.]
#
# axis=[x,y,z]
#
# xyz=[prod for prod in it.product(x,y,z)]
# values=[]
# for i in xrange(0,len(x)):
#     for j in xrange(0,len(y)):
#         for k in xrange(0,len(z)):
#             values.append(x[i]*y[j]*z[k])
#             print np.array([i,j,k]),np.array([x[i],y[j],z[k]]),x[i]*y[j]*z[k]
#
# vector=[axis,values]
#
#
#
#    
#
# print ''; teste=np.array([1.6,4.8,8.8])
# interp=interpLinND(teste,axis,values)
# print teste,interp
#
# print ''; teste=np.array([1.0,3.0,6.0])
# interp=interpLinND(teste,axis,values)
# print teste,interp
#
# print ''; teste=np.array([1.0,4.0,9.0])
# interp=interpLinND(teste,axis,values)
# print teste,interp
#
# print ''; teste=np.array([3.0,4.0,8.0])
# interp=interpLinND(teste,axis,values)
# print teste,interp
#
# print ''; teste=np.array([0.0,0.0,0.0])
# interp=interpLinND(teste,axis,values)
# print teste,interp
#
#....................................................................
####################################################################

def pogson(X,zp):
    return -2.5*np.log10(X)+zp


def VEGA_spct(spct_name):

    if spct_name == 'spct1':
        spct1=cwd+'/filters_spectra/fm05t9550g395k2odfnew.dat'
        f0 = open(spct1,'r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(12,len(lines))] # Eliminating text and separating columns

        dist_fac=1./(1.62*10.**16.)
        lamb=np.array([float(lines[i][2])*10. for i in xrange(0,len(lines))]) # lambda [angstroms]
        flambda=np.array([10.**(np.log10(4.*np.pi)+np.log10(phc.c.cgs)+np.log10(float(lines[i][4]))\
                            -2.*np.log10(float(lines[i][2])*10.**-7.)) \
                            for i in xrange(0,len(lines))])/10.**8.*dist_fac # flambda [erg cm^-2 s^-1 A^-1]
        return lamb,flambda
    #elif archive == 

#lalala=VEGA_spct('spct1')
#import sys;sys.exit()


def photosystem_k(name):
    if name == 'STMAG': return 0.00
    elif name == 'white': return 0.00
    elif name == 'bess-u': return 0.03
    elif name == 'bess-b': return 0.03
    elif name == 'bess-v': return 0.03
    elif name == 'bess-r': return 0.03
    elif name == 'bess-i': return 0.03
    elif name == 'bess-j': return 0.03
    elif name == 'bess-h': return 0.03
    elif name == 'bess-k': return 0.03
    elif name == 'bess-l': return 0.03
    elif name == 'bess-ll': return 0.03
    elif name == 'bess-m': return 0.03
    elif name == 'cohen-j': return 0.00
    elif name == 'cohen-h': return 0.00
    elif name == 'cohen-k': return 0.00
    elif name == 'crawford-stromgren-u': return 1.445
    elif name == 'crawford-stromgren-v': return 0.195
    elif name == 'crawford-stromgren-b': return 0.034
    elif name == 'crawford-stromgren-y': return 0.030
    elif name == 'int_wfc-hbetan': return 99.
    elif name == 'int_wfc-hbetaw': return 99.
    elif name == 'int_wfc-halpha': return 99.
    else: 
        func_name = sys._getframe().f_code.co_name
        print '<<',func_name,'>>'
        print name,' ?? I do not know which filter is that!'
        print ''
        return np.nan


def filter_passband(name):
    
    if name == 'STMAG':
        func_name = sys._getframe().f_code.co_name
        #print '<<',func_name,'>>'
        #print 'Warning! A passband for STMAG was requested! I am returning NaN to the calculation.'
        #print ''
        return np.nan,np.nan
    elif name == 'white':
        return np.array([0.,10.**99.]),np.array([1.,1.])
    elif name == 'bess-u':
        f0 = open(cwd+'/filters_spectra/bess-u.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-b':
        f0 = open(cwd+'/filters_spectra/bess-b.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-v':
        f0 = open(cwd+'/filters_spectra/bess-v.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-r':
        f0 = open(cwd+'/filters_spectra/bess-r.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-i':
        f0 = open(cwd+'/filters_spectra/bess-i.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-j':
        f0 = open(cwd+'/filters_spectra/bess-j.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-h':
        f0 = open(cwd+'/filters_spectra/bess-h.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-k':
        f0 = open(cwd+'/filters_spectra/bess-k.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-l':
        f0 = open(cwd+'/filters_spectra/bess-l.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-ll':
        f0 = open(cwd+'/filters_spectra/bess-ll.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'bess-m':
        f0 = open(cwd+'/filters_spectra/bess-m.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'cohen-j':
        f0 = open(cwd+'/filters_spectra/cohen-j.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0])*10000. for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'cohen-h':
        f0 = open(cwd+'/filters_spectra/cohen-h.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0])*10000. for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'cohen-k':
        f0 = open(cwd+'/filters_spectra/cohen-k.pass','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(1,len(lines))]
        lamb=np.array([float(lines[i][0])*10000. for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1]) for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'crawford-stromgren-u':
        f0 = open(cwd+'/filters_spectra/crawford-stromgren-u.filter','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(2,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1])/100. for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'crawford-stromgren-v':
        f0 = open(cwd+'/filters_spectra/crawford-stromgren-v.filter','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(2,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1])/100. for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'crawford-stromgren-b':
        f0 = open(cwd+'/filters_spectra/crawford-stromgren-b.filter','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(2,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1])/100. for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'crawford-stromgren-y':
        f0 = open(cwd+'/filters_spectra/crawford-stromgren-y.filter','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(2,len(lines))]
        lamb=np.array([float(lines[i][0]) for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1])/100. for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'int_wfc-hbetan':
        f0 = open(cwd+'/filters_spectra/int_wfc-hbetan.filter','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(12,len(lines))]
        lamb=np.array([float(lines[i][0])*10. for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1])/100. for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'int_wfc-hbetaw':
        f0 = open(cwd+'/filters_spectra/int_wfc-hbetaw.filter','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(12,len(lines))]
        lamb=np.array([float(lines[i][0])*10. for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1])/100. for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    elif name == 'int_wfc-halpha':
        f0 = open(cwd+'/filters_spectra/int_wfc-halpha.filter','r')
        lines = f0.readlines()
        f0.close()
        lines=[lines[i].split() for i in xrange(12,len(lines))]
        lamb=np.array([float(lines[i][0])*10. for i in xrange(0,len(lines))]) # lambda (Angstroms)
        R=np.array([float(lines[i][1])/100. for i in xrange(0,len(lines))]) # Reponse function
        return lamb,R
    else: 
        func_name = sys._getframe().f_code.co_name
        print '<<',func_name,'>>'
        print name,' ?? I do not know which filter is that!'
        print ''
        return np.nan,np.nan


def photonflux(lamb,flambda,rfunct,npts=200):
    
    lamb_r,R=filter_passband(rfunct)
    if rfunct == 'white':
        dens=np.array(lamb)*10.**-8.*np.array(flambda)/phc.h.cgs/phc.c.cgs
        l=np.array([np.nanmin(lamb)+(np.nanmax(lamb)-np.nanmin(lamb))/float(npts-1)*float(i) for i in xrange(0,npts)])
        dl=np.array([l[i+1]-l[i] for i in xrange(0,npts-1)])
        d=np.array([interpLinND([l[i]],[lamb],dens) for i in xrange(0,npts)])
        photflux=integrate_trapezia(d,dl)
        return photflux
    elif np.nanmin(lamb_r) >= np.nanmin(lamb) and np.nanmax(lamb_r) <= np.nanmax(lamb):
        dens=np.array(lamb)*10.**-8.*np.array(flambda)/phc.h.cgs/phc.c.cgs
        l=np.array([np.nanmin(lamb_r)+(np.nanmax(lamb_r)-np.nanmin(lamb_r))/float(npts-1)*float(i) for i in xrange(0,npts)])
        dl=np.array([l[i+1]-l[i] for i in xrange(0,npts-1)])
        d=np.array([interpLinND([l[i]],[lamb],dens) for i in xrange(0,npts)])
        r=np.array([interpLinND([l[i]],[lamb_r],R) for i in xrange(0,npts)])
        photflux=integrate_trapezia(d*r,dl)
        return photflux
    else: return np.nan



def obtain_pogson_zp(spct_name,filtername,npts=200):

    lamb,flambda=VEGA_spct(spct_name)
    if filtername == 'STMAG':
        flb=interpLinND([5480.],[lamb],flambda)
        k=photosystem_k(filtername)
        zp=2.5*np.log10(flb)+k
        return zp
    else:
        photflux=photonflux(lamb,flambda,filtername,npts)
        k=photosystem_k(filtername)
        zp=2.5*np.log10(photflux)+k
        return zp


def fullsed_2_photonflux(fullsed,source,filter,npts=200,dist=10.):
    # only the total flux (dont care about polarization)
    # I am not taking phi into account. Currently, this function is only usable for axisymmetric simulations.
    f0 = open(fullsed,'r')
    lines = f0.readlines()
    f0.close()
    nlbd=int(lines[3].split()[0]); nobs=int(lines[3].split()[1])
    lines=[lines[i].split() for i in xrange(5,len(lines))]
    mu=[];lamb=[];flambda=[];photflux=[]
    
    f0 = open(source,'r')
    src = f0.readlines()
    f0.close()
    lum=float(src[6].split()[2])
    normflx=10.**(-np.log10(4.*np.pi)-2.*np.log10(dist)-2.*np.log10(phc.pc.cgs)+np.log10(lum)+np.log10(phc.Lsun.cgs))

    for iob in xrange(0,nobs):
        mu_aux=float(lines[0+nlbd*iob][0])
        lamb_aux=np.array([float(lines[ilamb+nlbd*iob][2])*10000. for ilamb in xrange(0,nlbd)])
        flambda_aux=np.array([float(lines[ilamb+nlbd*iob][3])/10.**-4.*normflx/10.**8. for ilamb in xrange(0,nlbd)])
        photflux_aux=photonflux(lamb_aux,flambda_aux,filter,npts)
        mu.append(mu_aux);lamb.append(lamb_aux);flambda.append(flambda_aux);photflux.append(photflux_aux)
    return mu,lamb,flambda,photflux



    

#filters=[   'STMAG','white',\
#            'bess-u','bess-b','bess-v','bess-r','bess-i',\
#            'bess-j','bess-h','bess-k','bess-l','bess-ll','bess-m',\
#            'cohen-j','cohen-h','cohen-k',\
#            'crawford-stromgren-u','crawford-stromgren-v','crawford-stromgren-b','crawford-stromgren-y',\
#            'int_wfc-hbetan','int_wfc-hbetaw',\
#            'int_wfc-halpha'
#            ]
#            
#fullsed='fullsed_mod01_noCS_2.35E13_Nph10E6_Nbins025_iseedm1.sed2'
#source='Be_M15.00_ob1.33_H0.30_Z0.002_bE_Ell.txt'
#
#for i in xrange(0,len(filters)):
#    photflx=fullsed_2_photonflux(fullsed,source,filters[i])
#    print [[photflx[0][j],pogson(photflx[3][j],obtain_pogson_zp('spct1',filters[i]))] for j in xrange(0,len(photflx[3]))]
#    print ''










